"use client";

import { useCommunications } from "@/app/hooks/use-communications";
import { useDonors } from "@/app/hooks/use-donors";
import { useOrganization } from "@/app/hooks/use-organization";
import { useProjects } from "@/app/hooks/use-projects";
import { formatDonorName } from "@/app/lib/utils/donor-name-formatter";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Users, Mail, Plus } from "lucide-react";
import { cn } from "@/lib/utils";
import React, { useCallback, useEffect, useMemo, useRef, useState, useLayoutEffect } from "react";
import { Mention, MentionsInput } from "react-mentions";
import { toast } from "sonner";
import { useAuth } from "@clerk/nextjs";
import { EmailListViewer, BaseGeneratedEmail, BaseDonor } from "../components/EmailListViewer";
import { SuggestedMemories } from "../components/SuggestedMemories";
import "../styles.css";

interface WriteInstructionStepProps {
  instruction: string;
  onInstructionChange: (instruction: string) => void;
  onBack: () => void;
  onNext: () => void;
  selectedDonors: number[];
  onSessionDataChange?: (sessionData: {
    chatHistory: Array<{ role: "user" | "assistant"; content: string }>;
    finalInstruction: string;
    previewDonorIds: number[];
    generatedEmails?: GeneratedEmail[];
    referenceContexts?: Record<number, Record<string, string>>;
  }) => void;
  templatePrompt?: string; // Optional template prompt to pre-populate
  initialChatHistory?: Array<{ role: "user" | "assistant"; content: string }>;
  initialGeneratedEmails?: GeneratedEmail[];
  initialReferenceContexts?: Record<number, Record<string, string>>;
  initialPreviewDonorIds?: number[];
  campaignName: string;
  templateId?: number;
  onBulkGenerationComplete: (sessionId: number) => void;
  ref?: React.RefObject<{ click: () => Promise<void> }>;
  // Edit mode props
  editMode?: boolean;
  existingCampaignId?: number;
}

// Configuration for preview donor count - can be changed later
const PREVIEW_DONOR_COUNT = 50;
const EMAILS_PER_PAGE = 10;
const GENERATE_MORE_COUNT = 50;

interface GeneratedEmail {
  donorId: number;
  subject: string;
  structuredContent: Array<{
    piece: string;
    references: string[];
    addNewlineAfter: boolean;
  }>;
  referenceContexts: Record<string, string>;
}

interface ThreadMessage {
  id: number;
  content: string;
  datetime: Date;
  threadId: number;
}

interface ReferenceContext {
  [key: string]: {
    content: string;
    type: "donation" | "communication" | "summary";
    datetime?: string;
  };
}

interface GenerateEmailsResponse {
  emails: GeneratedEmail[];
  refinedInstruction: string;
  suggestedMemories?: string[];
}

interface AgenticFlowResponse {
  isAgenticFlow: true;
  sessionId: string;
  needsUserInput: boolean;
  isComplete: boolean;
  conversation: Array<{
    role: "user" | "assistant";
    content: string;
    timestamp: Date | string;
    stepType?: "question" | "confirmation" | "generation" | "complete";
  }>;
  canProceed?: boolean;
}

type EmailGenerationResult = GenerateEmailsResponse | AgenticFlowResponse;

export const WriteInstructionStep = React.forwardRef<{ click: () => Promise<void> }, WriteInstructionStepProps>(
  function WriteInstructionStep(
    {
      instruction,
      onInstructionChange,
      onBack,
      onNext,
      selectedDonors,
      onSessionDataChange,
      templatePrompt,
      initialChatHistory = [],
      initialGeneratedEmails = [],
      initialReferenceContexts = {},
      initialPreviewDonorIds = [],
      campaignName,
      templateId,
      onBulkGenerationComplete,
      editMode = false,
      existingCampaignId,
    },
    ref
  ) {
    const [isGenerating, setIsGenerating] = useState(false);
    const [chatMessages, setChatMessages] =
      useState<Array<{ role: "user" | "assistant"; content: string }>>(initialChatHistory);
    const [generatedEmails, setGeneratedEmails] = useState<GeneratedEmail[]>(initialGeneratedEmails);
    const [referenceContexts, setReferenceContexts] =
      useState<Record<number, Record<string, string>>>(initialReferenceContexts);
    const [previousInstruction, setPreviousInstruction] = useState<string | undefined>();
    const [suggestedMemories, setSuggestedMemories] = useState<string[]>([]);
    const [previewDonorIds, setPreviewDonorIds] = useState<number[]>(initialPreviewDonorIds);
    const [hasAutoGeneratedFromTemplate, setHasAutoGeneratedFromTemplate] = useState(false);
    const [showBulkGenerationDialog, setShowBulkGenerationDialog] = useState(false);
    const [isStartingBulkGeneration, setIsStartingBulkGeneration] = useState(false);
    const [allGeneratedEmails, setAllGeneratedEmails] = useState<GeneratedEmail[]>(initialGeneratedEmails);
    const [isGeneratingMore, setIsGeneratingMore] = useState(false);
    const [activeTab, setActiveTab] = useState("chat");
    const chatEndRef = useRef<HTMLDivElement>(null);
    const lastPersistedData = useRef<string>("");

    const { getOrganization } = useOrganization();
    const { generateEmails, createSession, updateCampaign } = useCommunications();
    const { listProjects } = useProjects();
    const { userId } = useAuth();

    // Batch fetch donor data for all selected donors
    const { getDonorsQuery } = useDonors();
    const { data: donorsData } = getDonorsQuery(selectedDonors);
    const { data: organization } = getOrganization();

    // Fetch projects for mentions
    const {
      data: projectsData,
      isLoading: isLoadingProjects,
      error: projectsError,
    } = listProjects({
      active: true,
      limit: 100, // Get all active projects
    });

    // Transform projects data for react-mentions
    const projectMentions = useMemo(() => {
      if (!projectsData?.projects) {
        return [];
      }

      return projectsData.projects.map((project) => ({
        id: project.id.toString(),
        display: project.name,
      }));
    }, [projectsData]);

    // Generate random subset of donors for preview on component mount (memoized to prevent recalculation)
    const initialPreviewDonors = useMemo(() => {
      if (selectedDonors.length > 0 && initialPreviewDonorIds.length === 0) {
        const shuffled = [...selectedDonors].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, Math.min(PREVIEW_DONOR_COUNT, selectedDonors.length));
      }
      return initialPreviewDonorIds;
    }, [selectedDonors, initialPreviewDonorIds]);

    // Set preview donors only once when component mounts
    useEffect(() => {
      if (previewDonorIds.length === 0 && initialPreviewDonors.length > 0) {
        setPreviewDonorIds(initialPreviewDonors);
      }
    }, [initialPreviewDonors, previewDonorIds.length]);

    // Memoize session data to avoid unnecessary recalculations
    const sessionData = useMemo(
      () => ({
        chatHistory: chatMessages,
        finalInstruction: previousInstruction || instruction,
        previewDonorIds,
        generatedEmails: allGeneratedEmails,
        referenceContexts,
      }),
      [chatMessages, previousInstruction, instruction, previewDonorIds, allGeneratedEmails, referenceContexts]
    );

    // Automatically persist session data whenever it changes (with throttling)
    useLayoutEffect(() => {
      if (onSessionDataChange && (chatMessages.length > 0 || allGeneratedEmails.length > 0)) {
        const currentDataString = JSON.stringify({
          chatHistory: sessionData.chatHistory,
          finalInstruction: sessionData.finalInstruction,
          previewDonorIds: sessionData.previewDonorIds,
          generatedEmailsCount: sessionData.generatedEmails.length,
          referenceContextsKeys: Object.keys(sessionData.referenceContexts),
        });

        // Only persist if the data has actually changed
        if (currentDataString !== lastPersistedData.current) {
          lastPersistedData.current = currentDataString;
          onSessionDataChange(sessionData);
        }
      }
    }, [sessionData, onSessionDataChange, chatMessages.length, allGeneratedEmails.length]);

    const scrollToBottom = () => {
      chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(() => {
      if (chatMessages.length > 0) {
        scrollToBottom();
      }
    }, [chatMessages]);

    const handleSubmitInstruction = useCallback(
      async (instructionToSubmit?: string) => {
        const finalInstruction = instructionToSubmit || instruction;
        if (!finalInstruction.trim() || !organization) return;

        setIsGenerating(true);
        // Clear existing emails and contexts
        setGeneratedEmails([]);
        setAllGeneratedEmails([]);
        setReferenceContexts({});
        setSuggestedMemories([]);
        setChatMessages((prev) => [...prev, { role: "user", content: finalInstruction }]);

        // Clear the input box only if this is manual submission (not auto-generation)
        if (!instructionToSubmit) {
          onInstructionChange("");
        }

        try {
          // Prepare donor data for the API call - use only preview donors
          const donorData = previewDonorIds.map((donorId) => {
            const donor = donorsData?.find((d) => d.id === donorId);
            if (!donor) throw new Error(`Donor data not found for ID: ${donorId}`);

            return {
              id: donor.id,
              firstName: donor.firstName,
              lastName: donor.lastName,
              email: donor.email,
            };
          });

          // Get current date in a readable format
          const currentDate = new Date().toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });

          // Generate emails using the hook
          const result = await generateEmails.mutateAsync({
            instruction: finalInstruction,
            donors: donorData,
            organizationName: organization.name,
            organizationWritingInstructions: organization.writingInstructions ?? undefined,
            previousInstruction,
            currentDate, // Pass the current date
            chatHistory: chatMessages, // Pass the full chat history to the refinement agent
          });

          if (result) {
            const typedResult = result as EmailGenerationResult;

            // Check if this is an agentic flow response
            if ("isAgenticFlow" in typedResult && typedResult.isAgenticFlow) {
              // Handle agentic flow response
              const agenticResult = typedResult as AgenticFlowResponse;

              // Add the conversation messages to chat
              const conversationMessages = agenticResult.conversation.map((msg) => ({
                role: msg.role,
                content: msg.content,
              }));

              setChatMessages((prev) => [...prev, ...conversationMessages]);

              // If it needs user input, we don't generate emails yet
              if (agenticResult.needsUserInput) {
                // TODO: Handle agentic conversation flow
                // For now, just show the conversation
                console.log("Agentic flow needs user input:", agenticResult);
                return;
              }
            } else {
              // Handle traditional email generation response
              const emailResult = typedResult as GenerateEmailsResponse;
              setAllGeneratedEmails(emailResult.emails);
              setGeneratedEmails(emailResult.emails);
              setPreviousInstruction(emailResult.refinedInstruction);

              setReferenceContexts(
                emailResult.emails.reduce<Record<number, Record<string, string>>>((acc, email) => {
                  acc[email.donorId] = email.referenceContexts;
                  return acc;
                }, {})
              );

              const responseMessage = instructionToSubmit
                ? "I've generated personalized emails using your selected template. You can review them on the left side and make any adjustments to the content or style if needed."
                : "I've generated personalized emails based on each donor's communication history and your organization's writing instructions. You can review them on the left side. Let me know if you'd like any adjustments to the tone, content, or style.";

              setChatMessages((prev) => [
                ...prev,
                {
                  role: "assistant",
                  content: responseMessage,
                },
              ]);

              // Auto-switch to preview tab after email generation
              setTimeout(() => {
                setActiveTab("preview");
              }, 500);
            }
          } else {
            throw new Error("Failed to generate emails");
          }
        } catch (error) {
          console.error("Error generating emails:", error);
          toast.error("Failed to generate emails. Please try again.");
          setChatMessages((prev) => [
            ...prev,
            {
              role: "assistant",
              content: "I apologize, but I encountered an error while generating the emails. Please try again.",
            },
          ]);
        } finally {
          setIsGenerating(false);
        }
      },
      [
        instruction,
        previewDonorIds,
        donorsData,
        organization,
        generateEmails,
        onInstructionChange,
        previousInstruction,
        chatMessages,
      ]
    );

    // Auto-generate emails when template prompt is provided - placed after handleSubmitInstruction is defined
    // Only auto-generate in non-edit mode
    useEffect(() => {
      if (
        !editMode && // Don't auto-generate in edit mode
        templatePrompt &&
        templatePrompt.trim() &&
        !hasAutoGeneratedFromTemplate &&
        previewDonorIds.length > 0 &&
        organization
      ) {
        setHasAutoGeneratedFromTemplate(true);
        // Set the instruction to the template prompt
        onInstructionChange(templatePrompt);
        // Auto-submit the template prompt
        handleSubmitInstruction(templatePrompt);
      }
    }, [
      editMode,
      templatePrompt,
      hasAutoGeneratedFromTemplate,
      previewDonorIds.length,
      organization,
      onInstructionChange,
      handleSubmitInstruction,
    ]);

    // Handle generating more emails with the same prompt
    const handleGenerateMore = useCallback(async () => {
      if (isGeneratingMore || !organization) return;

      const finalInstruction = previousInstruction || instruction;
      if (!finalInstruction.trim()) {
        toast.error("No instruction available to generate more emails");
        return;
      }

      // Get donors that haven't been generated yet
      const alreadyGeneratedDonorIds = new Set(allGeneratedEmails.map((email) => email.donorId));
      const remainingDonors = selectedDonors.filter((id) => !alreadyGeneratedDonorIds.has(id));

      if (remainingDonors.length === 0) {
        toast.error("All selected donors have emails generated already");
        return;
      }

      // Select next batch of donors (up to GENERATE_MORE_COUNT)
      const nextBatchDonors = remainingDonors.slice(0, Math.min(GENERATE_MORE_COUNT, remainingDonors.length));

      setIsGeneratingMore(true);

      try {
        // Prepare donor data for the API call
        const donorData = nextBatchDonors.map((donorId) => {
          const donor = donorsData?.find((d) => d.id === donorId);
          if (!donor) throw new Error(`Donor data not found for ID: ${donorId}`);

          return {
            id: donor.id,
            firstName: donor.firstName,
            lastName: donor.lastName,
            email: donor.email,
          };
        });

        // Get current date in a readable format
        const currentDate = new Date().toLocaleDateString("en-US", {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric",
        });

        // Generate emails using the same instruction
        const result = await generateEmails.mutateAsync({
          instruction: finalInstruction,
          donors: donorData,
          organizationName: organization.name,
          organizationWritingInstructions: organization.writingInstructions ?? undefined,
          previousInstruction,
          currentDate,
          chatHistory: chatMessages,
        });

        if (result && !("isAgenticFlow" in result)) {
          const emailResult = result as GenerateEmailsResponse;
          const newEmails = [...allGeneratedEmails, ...emailResult.emails];

          setAllGeneratedEmails(newEmails);
          setGeneratedEmails(newEmails);

          // Update reference contexts
          const newReferenceContexts = { ...referenceContexts };
          emailResult.emails.forEach((email) => {
            newReferenceContexts[email.donorId] = email.referenceContexts;
          });
          setReferenceContexts(newReferenceContexts);

          setChatMessages((prev) => [
            ...prev,
            {
              role: "assistant",
              content: `I've generated ${emailResult.emails.length} more personalized emails. You now have ${newEmails.length} emails total to review.`,
            },
          ]);

          toast.success(`Generated ${emailResult.emails.length} more emails successfully!`);
        } else {
          throw new Error("Failed to generate more emails");
        }
      } catch (error) {
        console.error("Error generating more emails:", error);
        toast.error("Failed to generate more emails. Please try again.");
        setChatMessages((prev) => [
          ...prev,
          {
            role: "assistant",
            content: "I apologize, but I encountered an error while generating more emails. Please try again.",
          },
        ]);
      } finally {
        setIsGeneratingMore(false);
      }
    }, [
      isGeneratingMore,
      organization,
      previousInstruction,
      instruction,
      allGeneratedEmails,
      selectedDonors,
      donorsData,
      generateEmails,
      referenceContexts,
      chatMessages,
    ]);

    // Handle bulk generation
    const handleBulkGeneration = async () => {
      if (isStartingBulkGeneration) return;

      if (!userId) {
        toast.error("User not authenticated");
        return;
      }

      if (allGeneratedEmails.length === 0) {
        toast.error("No emails to generate");
        return;
      }

      const finalInstruction = previousInstruction || instruction;
      if (!finalInstruction || finalInstruction.trim().length === 0) {
        toast.error("No instruction provided. Please generate emails first.");
        return;
      }

      const currentSessionData = {
        chatHistory: chatMessages,
        finalInstruction: finalInstruction.trim(),
        previewDonorIds,
      };

      setIsStartingBulkGeneration(true);
      try {
        let response: { sessionId: number };

        if (editMode && existingCampaignId) {
          // Update existing campaign
          await updateCampaign.mutateAsync({
            campaignId: existingCampaignId,
            campaignName: campaignName,
            instruction: currentSessionData.finalInstruction,
            chatHistory: currentSessionData.chatHistory,
            selectedDonorIds: selectedDonors,
            previewDonorIds: currentSessionData.previewDonorIds,
            refinedInstruction: currentSessionData.finalInstruction,
            templateId: templateId,
          });

          // Create new session for the updated campaign
          response = await createSession.mutateAsync({
            campaignName: campaignName,
            instruction: currentSessionData.finalInstruction,
            chatHistory: currentSessionData.chatHistory,
            selectedDonorIds: selectedDonors,
            previewDonorIds: currentSessionData.previewDonorIds,
            refinedInstruction: currentSessionData.finalInstruction,
            templateId: templateId,
          });
        } else {
          // Create new campaign session
          response = await createSession.mutateAsync({
            campaignName: campaignName,
            instruction: currentSessionData.finalInstruction,
            chatHistory: currentSessionData.chatHistory,
            selectedDonorIds: selectedDonors,
            previewDonorIds: currentSessionData.previewDonorIds,
            refinedInstruction: currentSessionData.finalInstruction,
            templateId: templateId,
          });
        }

        if (!response?.sessionId) {
          throw new Error("Failed to create session");
        }

        toast.success(
          editMode ? "Campaign updated and relaunched!" : "Campaign started! Redirecting to communication jobs..."
        );
        setShowBulkGenerationDialog(false);

        // Redirect after starting the generation
        setTimeout(() => {
          onBulkGenerationComplete(response.sessionId);
        }, 1000);
      } catch (error) {
        console.error("Error starting bulk generation:", error);
        toast.error(editMode ? "Failed to update and relaunch campaign" : "Failed to start bulk generation");
      } finally {
        setIsStartingBulkGeneration(false);
      }
    };

    // Handle next button click - show confirmation dialog
    const handleNextClick = () => {
      if (generatedEmails.length === 0) {
        toast.error("Please generate emails first before proceeding");
        return;
      }

      const finalInstruction = previousInstruction || instruction;
      if (!finalInstruction || finalInstruction.trim().length === 0) {
        toast.error("No instruction provided. Please generate emails first.");
        return;
      }

      // Pass session data to parent before showing dialog
      if (onSessionDataChange) {
        onSessionDataChange({
          chatHistory: chatMessages,
          finalInstruction: finalInstruction.trim(),
          previewDonorIds,
          generatedEmails,
          referenceContexts,
        });
      }

      setShowBulkGenerationDialog(true);
    };

    // Expose the handleSubmitInstruction function through a ref
    React.useImperativeHandle(ref, () => ({
      click: () => handleSubmitInstruction(),
    }));

    // Handle mentions input change
    const handleMentionChange = (event: any, newValue: string, newPlainTextValue: string, mentions: any[]) => {
      onInstructionChange(newValue);
    };

    // Handle keydown for submitting with Cmd/Ctrl + Enter
    const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>) => {
      if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
        event.preventDefault(); // Prevent default form submission or newline
        if (!isGenerating && instruction.trim()) {
          handleSubmitInstruction();
        }
      }
    };

    // Check if we can generate more emails
    const alreadyGeneratedDonorIds = new Set(allGeneratedEmails.map((email) => email.donorId));
    const remainingDonors = selectedDonors.filter((id) => !alreadyGeneratedDonorIds.has(id));
    const canGenerateMore = remainingDonors.length > 0;

    return (
      <div className="flex flex-col h-full space-y-6">
        {/* Main Content with Tabs */}
        <div className="flex-1 min-h-0">
          <Tabs value={activeTab} onValueChange={setActiveTab} className="h-full flex flex-col">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="chat" className="flex items-center gap-2">
                <Users className="h-4 w-4" />
                Chat & Generate
              </TabsTrigger>
              <TabsTrigger value="preview" className="flex items-center gap-2">
                <Plus className="h-4 w-4" />
                Email Preview ({allGeneratedEmails.length})
              </TabsTrigger>
            </TabsList>

            {/* Chat Tab */}
            <TabsContent value="chat" className="flex-1 min-h-0 mt-3">
              <div className="grid grid-cols-1 lg:grid-cols-1 gap-6 h-full">
                {/* Simplified Chat Interface */}
                <Card className="h-full flex flex-col">
                  <CardContent className="flex-1 flex flex-col min-h-0 p-0">
                    <div className="flex flex-col flex-1 min-h-0">
                      {/* Chat Messages */}
                      <ScrollArea className="flex-1 min-h-0">
                        <div className="p-6 space-y-4">
                          {templatePrompt && hasAutoGeneratedFromTemplate && chatMessages.length === 0 && (
                            <div className="flex flex-col space-y-2">
                              <div className="rounded-lg px-4 py-3 bg-blue-50 border border-blue-200">
                                <p className="text-sm text-blue-800">
                                  ℹ️ Using template to generate emails automatically...
                                </p>
                              </div>
                            </div>
                          )}
                          {chatMessages.length === 0 ? (
                            <div className="text-center py-12 text-muted-foreground">
                              <p>Start by writing instructions for email generation below.</p>
                            </div>
                          ) : (
                            chatMessages.map((message, index) => (
                              <div
                                key={index}
                                className={cn("flex flex-col space-y-2", {
                                  "items-end": message.role === "user",
                                })}
                              >
                                <div
                                  className={cn("rounded-lg px-4 py-3 max-w-[80%]", {
                                    "bg-primary text-primary-foreground": message.role === "user",
                                    "bg-muted": message.role === "assistant",
                                  })}
                                >
                                  <p className="text-sm whitespace-pre-wrap">{message.content}</p>
                                </div>
                                {message.role === "assistant" &&
                                  suggestedMemories.length > 0 &&
                                  index === chatMessages.length - 1 && (
                                    <div className="w-full mt-4">
                                      <SuggestedMemories memories={suggestedMemories} />
                                    </div>
                                  )}
                              </div>
                            ))
                          )}
                          <div ref={chatEndRef} />
                        </div>
                      </ScrollArea>

                      {/* Input Area */}
                      <div className="p-6 border-t bg-background">
                        <div className="space-y-4">
                          <div className="relative">
                            <MentionsInput
                              value={instruction}
                              onChange={handleMentionChange}
                              placeholder={
                                isLoadingProjects
                                  ? "Loading projects... Type @ to mention projects once loaded"
                                  : projectMentions.length > 0
                                  ? `Enter your instructions for email generation or continue the conversation... (Type @ to mention projects - ${projectMentions.length} available). Press Cmd/Ctrl + Enter to send.`
                                  : "Enter your instructions for email generation or continue the conversation... Press Cmd/Ctrl + Enter to send."
                              }
                              className="mentions-input min-h-[120px]"
                              onKeyDown={handleKeyDown}
                            >
                              <Mention
                                trigger="@"
                                data={projectMentions}
                                markup="@[__display__](__id__)"
                                displayTransform={(id, display) => `@${display}`}
                                appendSpaceOnAdd={true}
                              />
                            </MentionsInput>
                          </div>
                          <div className="flex justify-end">
                            <Button
                              onClick={() => handleSubmitInstruction()}
                              disabled={isGenerating || !instruction.trim()}
                              variant="default"
                            >
                              {isGenerating ? "Generating..." : "Generate Emails"}
                            </Button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              </div>
            </TabsContent>

            {/* Preview Tab */}
            <TabsContent value="preview" className="flex-1 min-h-0 mt-3">
              <Card className="h-full flex flex-col">
                {/* Only show header if we need the Generate More button */}
                {canGenerateMore && (
                  <CardHeader className="pb-3">
                    <div className="flex items-center justify-end">
                      <Button
                        variant="outline"
                        onClick={handleGenerateMore}
                        disabled={isGeneratingMore}
                        className="flex items-center gap-2"
                      >
                        <Plus className="h-4 w-4" />
                        {isGeneratingMore
                          ? "Generating..."
                          : `Generate ${Math.min(GENERATE_MORE_COUNT, remainingDonors.length)} More`}
                      </Button>
                    </div>
                  </CardHeader>
                )}
                <CardContent className="flex-1 min-h-0 p-0">
                  {isGenerating ? (
                    <div className="flex items-center justify-center h-full text-muted-foreground">
                      <div className="flex flex-col items-center gap-4">
                        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
                        <div className="text-center">
                          <p className="font-medium">Generating personalized emails...</p>
                          <p className="text-sm">This may take a few moments</p>
                        </div>
                      </div>
                    </div>
                  ) : allGeneratedEmails.length > 0 ? (
                    <div className="h-full p-6">
                      <EmailListViewer
                        emails={allGeneratedEmails}
                        donors={
                          donorsData
                            ?.filter((donor) => !!donor)
                            .map((donor) => ({
                              id: donor.id,
                              firstName: donor.firstName,
                              lastName: donor.lastName,
                              email: donor.email,
                              assignedToStaffId: donor.assignedToStaffId,
                            })) || []
                        }
                        referenceContexts={referenceContexts}
                        showSearch={true}
                        showPagination={true}
                        showTracking={false}
                        showStaffAssignment={false}
                        showSendButton={false}
                        showEditButton={false}
                        emailsPerPage={EMAILS_PER_PAGE}
                        maxHeight="calc(100vh - 280px)"
                        emptyStateTitle="No emails generated yet"
                        emptyStateDescription={
                          templatePrompt
                            ? "Generating emails from template..."
                            : "Switch to the Chat & Generate tab to generate emails"
                        }
                      />
                    </div>
                  ) : (
                    <div className="flex items-center justify-center h-full text-muted-foreground">
                      <div className="text-center space-y-4">
                        <div className="w-16 h-16 mx-auto bg-muted rounded-full flex items-center justify-center">
                          <Mail className="h-8 w-8" />
                        </div>
                        <div>
                          <p className="font-medium">No emails generated yet</p>
                          <p className="text-sm">
                            {templatePrompt
                              ? "Generating emails from template..."
                              : "Switch to the Chat & Generate tab to get started"}
                          </p>
                        </div>
                      </div>
                    </div>
                  )}
                </CardContent>
              </Card>
            </TabsContent>
          </Tabs>
        </div>

        {/* Bulk Generation Confirmation Dialog */}
        <Dialog open={showBulkGenerationDialog} onOpenChange={setShowBulkGenerationDialog}>
          <DialogContent className="max-w-2xl">
            <DialogHeader>
              <DialogTitle className="flex items-center gap-2">
                <Mail className="h-5 w-5" />
                {editMode ? "Confirm Campaign Update" : "Confirm Campaign Launch"}
              </DialogTitle>
              <DialogDescription>
                {editMode
                  ? "You're about to update and relaunch this campaign with your new instructions. This will generate additional emails for any new donors and update the campaign settings."
                  : "You're about to launch a campaign to generate personalized emails for all selected donors based on your current instruction."}
              </DialogDescription>
            </DialogHeader>

            <div className="space-y-4">
              {/* Summary Card */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2 text-base">
                    <Users className="h-4 w-4" />
                    Campaign Summary
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-1">
                      <p className="text-sm font-medium">Total Donors</p>
                      <p className="text-2xl font-bold">{selectedDonors.length}</p>
                    </div>
                    <div className="space-y-1">
                      <p className="text-sm font-medium">Preview Donors</p>
                      <p className="text-2xl font-bold">{previewDonorIds.length}</p>
                    </div>
                  </div>

                  <div className="space-y-2">
                    <p className="text-sm font-medium">Final Instruction</p>
                    <div className="p-3 bg-muted rounded-lg">
                      <p className="text-sm">
                        {(previousInstruction || instruction || "").trim() || "No instruction provided"}
                      </p>
                    </div>
                  </div>
                </CardContent>
              </Card>

              <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <p className="text-sm text-blue-800">
                  {editMode
                    ? `This will update and relaunch your campaign for all ${selectedDonors.length} selected donors. Only new emails will be generated for donors who don't already have them. You'll be redirected to the communication jobs page where you can monitor the progress.`
                    : `This will launch your campaign for all ${selectedDonors.length} selected donors. You'll be redirected to the communication jobs page where you can monitor the progress.`}
                </p>
              </div>
            </div>

            <DialogFooter>
              <Button
                variant="outline"
                onClick={() => setShowBulkGenerationDialog(false)}
                disabled={isStartingBulkGeneration}
              >
                Cancel
              </Button>
              <Button onClick={handleBulkGeneration} disabled={isStartingBulkGeneration}>
                {isStartingBulkGeneration
                  ? editMode
                    ? "Updating..."
                    : "Launching..."
                  : editMode
                  ? "Update Campaign"
                  : "Launch Campaign"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    );
  }
);
