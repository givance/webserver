import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { toast } from 'sonner';
import { useCommunications } from '@/app/hooks/use-communications';
import { PREVIEW_DONOR_COUNT } from '../constants';
import {
  GeneratedEmail,
  GenerateEmailsResponse,
  AgenticFlowResponse,
  EmailGenerationResult,
} from '../types';

export function useWriteInstructionStep(
  // Email state params
  initialGeneratedEmails: GeneratedEmail[] = [],
  editMode = false,

  // Chat state params
  initialChatHistory: Array<{ role: 'user' | 'assistant'; content: string }> = [],
  sessionId?: number,
  campaignName?: string,
  selectedDonors: number[] = [],
  templateId?: number,

  // Instruction input params
  instruction: string = '',
  onInstructionChange: (instruction: string) => void = () => {},
  templatePrompt?: string
) {
  // Email Generation State
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingMore, setIsGeneratingMore] = useState(false);
  const [isRegenerating, setIsRegenerating] = useState(false);

  // Email State
  const [generatedEmails, setGeneratedEmails] = useState<GeneratedEmail[]>(initialGeneratedEmails);
  const [allGeneratedEmails, setAllGeneratedEmails] =
    useState<GeneratedEmail[]>(initialGeneratedEmails);
  const [referenceContexts, setReferenceContexts] = useState<
    Record<number, Record<string, string>>
  >({});
  const [emailStatuses, setEmailStatuses] = useState<
    Record<number, 'PENDING_APPROVAL' | 'APPROVED'>
  >(() => {
    const statuses: Record<number, 'PENDING_APPROVAL' | 'APPROVED'> = {};
    initialGeneratedEmails.forEach((email) => {
      statuses[email.donorId] = (email as any).status || 'PENDING_APPROVAL';
    });
    return statuses;
  });
  const [isUpdatingStatus, setIsUpdatingStatus] = useState(false);

  // Chat State
  const [chatMessages, setChatMessages] =
    useState<Array<{ role: 'user' | 'assistant'; content: string }>>(initialChatHistory);
  const [suggestedMemories, setSuggestedMemories] = useState<string[]>([]);
  const chatEndRef = useRef<HTMLDivElement>(null);

  // Instruction Input State
  const [localInstruction, setLocalInstruction] = useState(instruction || '');
  const [hasInputContent, setHasInputContent] = useState(!!instruction);
  const [hasAutoGeneratedFromTemplate, setHasAutoGeneratedFromTemplate] = useState(false);
  const localInstructionRef = useRef(localInstruction);
  localInstructionRef.current = localInstruction;

  // Hooks
  const { saveGeneratedEmail, saveDraft, smartEmailGeneration } = useCommunications();

  // Email State Effects
  useEffect(() => {
    if (editMode && initialGeneratedEmails.length > 0) {
      setAllGeneratedEmails(initialGeneratedEmails);
      setGeneratedEmails(initialGeneratedEmails);

      const statuses: Record<number, 'PENDING_APPROVAL' | 'APPROVED'> = {};
      initialGeneratedEmails.forEach((email) => {
        statuses[email.donorId] = (email as any).status || 'PENDING_APPROVAL';
      });
      setEmailStatuses(statuses);

      const contexts: Record<number, Record<string, string>> = {};
      initialGeneratedEmails.forEach((email) => {
        if (email.referenceContexts) {
          contexts[email.donorId] = email.referenceContexts;
        }
      });
      setReferenceContexts(contexts);
    }
  }, [editMode, initialGeneratedEmails]);

  // Chat State Effects
  useEffect(() => {
    if (initialChatHistory.length > 0 && chatMessages.length === 0) {
      setChatMessages(initialChatHistory);
    }
  }, [initialChatHistory, chatMessages.length]);

  useEffect(() => {
    if (chatMessages.length > 0) {
      chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [chatMessages]);

  // Instruction Input Effects
  const instructionValue = instruction || '';
  useEffect(() => {
    setLocalInstruction(instructionValue);
    setHasInputContent(!!instructionValue.trim());
  }, [instructionValue]);

  useEffect(() => {
    if (
      templatePrompt &&
      templatePrompt.trim() &&
      chatMessages.length === 0 &&
      !hasAutoGeneratedFromTemplate
    ) {
      setLocalInstruction(templatePrompt);
      setHasInputContent(true);
      onInstructionChange(templatePrompt);
      setHasAutoGeneratedFromTemplate(true);
    }
  }, [templatePrompt, chatMessages.length, hasAutoGeneratedFromTemplate, onInstructionChange]);

  // Computed Values
  const { approvedCount, pendingCount } = useMemo(() => {
    const statuses = Object.values(emailStatuses);
    return {
      approvedCount: statuses.filter((status) => status === 'APPROVED').length,
      pendingCount: statuses.filter((status) => status === 'PENDING_APPROVAL').length,
    };
  }, [emailStatuses]);

  const { totalRemainingDonors, canGenerateMore } = useMemo(() => {
    const generatedIds = new Set(allGeneratedEmails.map((email) => email.donorId));
    const remainingDonors = selectedDonors.filter((id) => !generatedIds.has(id));

    return {
      totalRemainingDonors: remainingDonors.length,
      canGenerateMore: remainingDonors.length > 0,
    };
  }, [allGeneratedEmails, selectedDonors]);

  // Callbacks
  const smartEmailGenerationCallback = useCallback(
    async (params: {
      sessionId: number;
      mode: 'generate_more' | 'regenerate_all' | 'generate_with_new_message';
      count?: number;
      newMessage?: string;
    }): Promise<{
      message: string;
      success: boolean;
      chatHistory: Array<{ role: 'user' | 'assistant'; content: string }>;
    }> => {
      try {
        const result = await smartEmailGeneration.mutateAsync(params);
        return {
          message: result.message,
          success: result.success,
          chatHistory: result.chatHistory,
        };
      } catch (error) {
        console.error('Error with smart email generation:', error);
        toast.error('Failed to generate emails. Please try again.');
        throw error;
      }
    },
    [smartEmailGeneration]
  );

  const saveEmailsToSession = useCallback(
    async (emails: GeneratedEmail[], sessionId: number) => {
      if (!sessionId) return;

      const savePromises = emails.map(async (email) => {
        try {
          await saveGeneratedEmail.mutateAsync({
            sessionId,
            donorId: email.donorId,
            subject: email.subject,
            structuredContent: email.structuredContent,
            referenceContexts: email.referenceContexts,
            emailContent: email.emailContent,
            reasoning: email.reasoning,
            response: email.response,
            isPreview: true,
          });
          return email;
        } catch (error) {
          console.error(`Failed to save email for donor ${email.donorId}:`, error);
          return email;
        }
      });

      Promise.all(savePromises).catch((error) => {
        console.error(`Error saving some emails:`, error);
      });
    },
    [saveGeneratedEmail]
  );

  const saveChatHistory = useCallback(
    async (
      messages?: Array<{ role: 'user' | 'assistant'; content: string }>,
      refinedInst?: string
    ) => {
      if (!sessionId || !campaignName) {
        return;
      }

      const messagesToSave = messages || chatMessages;

      try {
        await saveDraft.mutateAsync({
          sessionId,
          campaignName,
          selectedDonorIds: selectedDonors,
          templateId,
          chatHistory: messagesToSave,
        });
        console.log(
          '[useWriteInstructionStep] Successfully saved chat history with',
          messagesToSave.length,
          'messages'
        );
      } catch (error) {
        console.error('[useWriteInstructionStep] Failed to save chat history:', error);
      }
    },
    [sessionId, campaignName, saveDraft, selectedDonors, templateId, chatMessages]
  );

  const handleInstructionValueChange = useCallback((value: string) => {
    setLocalInstruction(value);
    localInstructionRef.current = value;
    setHasInputContent(!!value.trim());
  }, []);

  const clearInput = useCallback(() => {
    console.log('[useWriteInstructionStep] Clearing input');
    setLocalInstruction('');
    localInstructionRef.current = '';
    setHasInputContent(false);
    onInstructionChange('');
  }, [onInstructionChange]);

  return {
    // Email Generation State
    emailGeneration: {
      isGenerating,
      setIsGenerating,
      isGeneratingMore,
      setIsGeneratingMore,
      isRegenerating,
      setIsRegenerating,
      smartEmailGeneration: smartEmailGenerationCallback,
      saveEmailsToSession: async (emails: GeneratedEmail[], sessionId: number) => {
        // This can be implemented if needed for saving emails individually
        // For now, emails are saved automatically by the backend
        console.log('Saving emails:', emails.length, 'to session:', sessionId);
      },
    },

    // Email State
    emailState: {
      generatedEmails,
      setGeneratedEmails,
      allGeneratedEmails,
      setAllGeneratedEmails,
      referenceContexts,
      setReferenceContexts,
      emailStatuses,
      setEmailStatuses,
      isUpdatingStatus,
      setIsUpdatingStatus,
      approvedCount,
      pendingCount,
    },

    // Chat State
    chatState: {
      chatMessages,
      setChatMessages,
      suggestedMemories,
      setSuggestedMemories,
      chatEndRef,
      saveChatHistory,
    },

    // Instruction Input
    instructionInput: {
      localInstruction,
      setLocalInstruction,
      localInstructionRef,
      hasInputContent,
      handleInstructionValueChange,
      clearInput,
    },

    // Donor State
    donorState: {
      totalRemainingDonors,
      canGenerateMore,
    },
  };
}
