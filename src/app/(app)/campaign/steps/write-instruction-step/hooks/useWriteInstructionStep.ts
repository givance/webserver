import { useState, useEffect, useRef, useCallback, useMemo } from "react";
import { toast } from "sonner";
import { useCommunications } from "@/app/hooks/use-communications";
import { PREVIEW_DONOR_COUNT } from "../constants";
import { 
  GeneratedEmail, 
  GenerateEmailsResponse, 
  AgenticFlowResponse, 
  EmailGenerationResult 
} from "../types";

export function useWriteInstructionStep(
  // Email state params
  initialGeneratedEmails: GeneratedEmail[] = [],
  editMode = false,
  
  // Chat state params
  initialChatHistory: Array<{ role: "user" | "assistant"; content: string }> = [],
  sessionId?: number,
  campaignName?: string,
  selectedDonors: number[] = [],
  templateId?: number,
  
  // Instruction input params
  instruction: string = "",
  onInstructionChange: (instruction: string) => void = () => {},
  templatePrompt?: string,
  
  // Preview donors params
  initialPreviewDonorIds: number[] = []
) {
  // Email Generation State
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingMore, setIsGeneratingMore] = useState(false);
  const [isRegenerating, setIsRegenerating] = useState(false);
  
  // Email State
  const [generatedEmails, setGeneratedEmails] = useState<GeneratedEmail[]>(initialGeneratedEmails);
  const [allGeneratedEmails, setAllGeneratedEmails] = useState<GeneratedEmail[]>(initialGeneratedEmails);
  const [referenceContexts, setReferenceContexts] = useState<Record<number, Record<string, string>>>({});
  const [emailStatuses, setEmailStatuses] = useState<Record<number, "PENDING_APPROVAL" | "APPROVED">>(() => {
    const statuses: Record<number, "PENDING_APPROVAL" | "APPROVED"> = {};
    initialGeneratedEmails.forEach((email) => {
      statuses[email.donorId] = (email as any).status || "PENDING_APPROVAL";
    });
    return statuses;
  });
  const [isUpdatingStatus, setIsUpdatingStatus] = useState(false);

  // Chat State
  const [chatMessages, setChatMessages] = useState<Array<{ role: "user" | "assistant"; content: string }>>(initialChatHistory);
  const [suggestedMemories, setSuggestedMemories] = useState<string[]>([]);
  const chatEndRef = useRef<HTMLDivElement>(null);

  // Instruction Input State
  const [localInstruction, setLocalInstruction] = useState(instruction || "");
  const [hasInputContent, setHasInputContent] = useState(!!instruction);
  const [hasAutoGeneratedFromTemplate, setHasAutoGeneratedFromTemplate] = useState(false);
  const localInstructionRef = useRef(localInstruction);
  localInstructionRef.current = localInstruction;

  // Preview Donors State
  const [previewDonorIds, setPreviewDonorIds] = useState<number[]>(initialPreviewDonorIds);
  const hasGeneratedPreviewRef = useRef(false);

  // Hooks
  const { generateEmails, saveGeneratedEmail, saveDraft } = useCommunications();

  // Email State Effects
  useEffect(() => {
    if (editMode && initialGeneratedEmails.length > 0) {
      console.log("[useWriteInstructionStep] Updating emails from props:", initialGeneratedEmails.length);
      setAllGeneratedEmails(initialGeneratedEmails);
      setGeneratedEmails(initialGeneratedEmails);

      const statuses: Record<number, "PENDING_APPROVAL" | "APPROVED"> = {};
      initialGeneratedEmails.forEach((email) => {
        statuses[email.donorId] = (email as any).status || "PENDING_APPROVAL";
      });
      setEmailStatuses(statuses);

      const contexts: Record<number, Record<string, string>> = {};
      initialGeneratedEmails.forEach((email) => {
        if (email.referenceContexts) {
          contexts[email.donorId] = email.referenceContexts;
        }
      });
      setReferenceContexts(contexts);
    }
  }, [editMode, initialGeneratedEmails]);

  // Chat State Effects
  useEffect(() => {
    if (initialChatHistory.length > 0 && chatMessages.length === 0) {
      console.log("[useWriteInstructionStep] Loading chat history from props:", initialChatHistory.length, "messages");
      setChatMessages(initialChatHistory);
    }
  }, [initialChatHistory, chatMessages.length]);

  useEffect(() => {
    if (chatMessages.length > 0) {
      chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [chatMessages]);

  // Instruction Input Effects
  useEffect(() => {
    console.log("[useWriteInstructionStep] instruction prop changed:", {
      instructionLength: instruction?.length || 0,
      localInstructionLength: localInstruction?.length || 0,
      willUpdate: instruction !== localInstruction,
    });
    if (instruction !== localInstruction) {
      setLocalInstruction(instruction || "");
      setHasInputContent(!!instruction?.trim());
    }
  }, [instruction, localInstruction]);

  useEffect(() => {
    if (
      templatePrompt &&
      templatePrompt.trim() &&
      chatMessages.length === 0 &&
      !hasAutoGeneratedFromTemplate
    ) {
      setLocalInstruction(templatePrompt);
      setHasInputContent(true);
      onInstructionChange(templatePrompt);
      setHasAutoGeneratedFromTemplate(true);
    }
  }, [templatePrompt, chatMessages.length, hasAutoGeneratedFromTemplate, onInstructionChange]);

  // Preview Donors Effects
  useEffect(() => {
    if (previewDonorIds.length > 0) {
      return;
    }

    if (initialPreviewDonorIds.length > 0) {
      setPreviewDonorIds(initialPreviewDonorIds);
      return;
    }

    if (!hasGeneratedPreviewRef.current && selectedDonors.length > 0) {
      console.log("[useWriteInstructionStep] Generating random preview donors - this should only happen ONCE");
      const shuffled = [...selectedDonors].sort(() => 0.5 - Math.random());
      const preview = shuffled.slice(0, Math.min(PREVIEW_DONOR_COUNT, selectedDonors.length));
      setPreviewDonorIds(preview);
      hasGeneratedPreviewRef.current = true;
    }
  }, [initialPreviewDonorIds, previewDonorIds.length, selectedDonors]);

  // Computed Values
  const { approvedCount, pendingCount } = useMemo(() => {
    const statuses = Object.values(emailStatuses);
    return {
      approvedCount: statuses.filter((status) => status === "APPROVED").length,
      pendingCount: statuses.filter((status) => status === "PENDING_APPROVAL").length,
    };
  }, [emailStatuses]);

  const {
    remainingFromPreview,
    remainingFromSelected,
    totalRemainingDonors,
    canGenerateMore,
  } = useMemo(() => {
    const generatedIds = new Set(allGeneratedEmails.map((email) => email.donorId));
    const remainingPreview = previewDonorIds.filter((id) => !generatedIds.has(id));
    const remainingSelected = selectedDonors.filter((id) => !generatedIds.has(id) && !previewDonorIds.includes(id));
    const totalRemaining = remainingPreview.length + remainingSelected.length;

    return {
      remainingFromPreview: remainingPreview,
      remainingFromSelected: remainingSelected,
      totalRemainingDonors: totalRemaining,
      canGenerateMore: totalRemaining > 0,
    };
  }, [allGeneratedEmails, previewDonorIds, selectedDonors]);

  // Callbacks
  const generateEmailsForDonors = useCallback(async (params: {
    instruction: string;
    donors: Array<{
      id: number;
      firstName: string;
      lastName: string;
      email: string;
    }>;
    organizationName: string;
    organizationWritingInstructions?: string;
    previousInstruction?: string;
    currentDate?: string;
    chatHistory?: Array<{ role: "user" | "assistant"; content: string }>;
    signature?: string;
  }): Promise<EmailGenerationResult | null> => {
    try {
      const result = await generateEmails.mutateAsync(params);
      return result as EmailGenerationResult;
    } catch (error) {
      console.error("Error generating emails:", error);
      toast.error("Failed to generate emails. Please try again.");
      throw error;
    }
  }, [generateEmails]);

  const saveEmailsToSession = useCallback(async (
    emails: GeneratedEmail[], 
    sessionId: number
  ) => {
    if (!sessionId) return;

    const savePromises = emails.map(async (email) => {
      try {
        await saveGeneratedEmail.mutateAsync({
          sessionId,
          donorId: email.donorId,
          subject: email.subject,
          structuredContent: email.structuredContent,
          referenceContexts: email.referenceContexts,
          emailContent: email.emailContent,
          reasoning: email.reasoning,
          response: email.response,
          isPreview: true,
        });
        return email;
      } catch (error) {
        console.error(`Failed to save email for donor ${email.donorId}:`, error);
        return email;
      }
    });

    Promise.all(savePromises).catch((error) => {
      console.error(`Error saving some emails:`, error);
    });
  }, [saveGeneratedEmail]);

  const saveChatHistory = useCallback(
    async (messages?: Array<{ role: "user" | "assistant"; content: string }>, refinedInst?: string) => {
      if (!sessionId || !campaignName) {
        console.log("[useWriteInstructionStep] Skipping chat history save - no sessionId or campaignName");
        return;
      }

      const messagesToSave = messages || chatMessages;

      console.log("[useWriteInstructionStep] Saving chat history", {
        sessionId,
        chatMessagesCount: messagesToSave.length,
        lastMessage: messagesToSave[messagesToSave.length - 1],
      });

      try {
        await saveDraft.mutateAsync({
          sessionId,
          campaignName,
          selectedDonorIds: selectedDonors,
          templateId,
          instruction,
          chatHistory: messagesToSave,
          previewDonorIds,
        });
        console.log("[useWriteInstructionStep] Successfully saved chat history with", messagesToSave.length, "messages");
      } catch (error) {
        console.error("[useWriteInstructionStep] Failed to save chat history:", error);
      }
    },
    [sessionId, campaignName, saveDraft, chatMessages, instruction, previewDonorIds, selectedDonors, templateId]
  );

  const handleInstructionValueChange = useCallback((value: string) => {
    localInstructionRef.current = value;
    setHasInputContent(!!value.trim());
  }, []);

  const clearInput = useCallback(() => {
    console.log("[useWriteInstructionStep] Clearing input");
    setLocalInstruction("");
    localInstructionRef.current = "";
    setHasInputContent(false);
    onInstructionChange("");
  }, [onInstructionChange]);

  return {
    // Email Generation
    emailGeneration: {
      isGenerating,
      setIsGenerating,
      isGeneratingMore,
      setIsGeneratingMore,
      isRegenerating,
      setIsRegenerating,
      generateEmailsForDonors,
      saveEmailsToSession,
    },
    
    // Email State
    emailState: {
      generatedEmails,
      setGeneratedEmails,
      allGeneratedEmails,
      setAllGeneratedEmails,
      referenceContexts,
      setReferenceContexts,
      emailStatuses,
      setEmailStatuses,
      isUpdatingStatus,
      setIsUpdatingStatus,
      approvedCount,
      pendingCount,
    },
    
    // Chat State
    chatState: {
      chatMessages,
      setChatMessages,
      suggestedMemories,
      setSuggestedMemories,
      chatEndRef,
      saveChatHistory,
    },
    
    // Instruction Input
    instructionInput: {
      localInstruction,
      setLocalInstruction,
      localInstructionRef,
      hasInputContent,
      handleInstructionValueChange,
      clearInput,
    },
    
    // Preview Donors
    previewDonors: {
      previewDonorIds,
      setPreviewDonorIds,
      remainingFromPreview,
      remainingFromSelected,
      totalRemainingDonors,
      canGenerateMore,
    },
  };
}